use ndarray::{Array3, Zip};
use ndarray_parallel::prelude::*;
use slog::Logger;
use potential;
use config::*;

#[derive(Debug)]
pub struct Potentials {
    pub v: Array3<f64>,
    a: Array3<f64>,
    b: Array3<f64>,
    epsilon: f64,
}

/// Parameters generated by the initialisation routine, potentials and wavefunction (phi).
#[derive(Debug)]
struct Params {
    potentials: Potentials,
    phi: Array3<f64>,
}

fn load_potential_arrays(config: &Config) -> Potentials {
    let mut minima: f64 = 1e20;

    let result = match config.potential {
        PotentialType::FromFile => potential::from_file(),
        PotentialType::FromScript => potential::from_script(),
        _ => potential::generate(config),
    };
    let v: Array3<f64> = match result {
        Ok(r) => r,
        Err(err) => panic!("Error: {}", err),
    };


    let b = 1. / (1. + config.grid.dt * &v / 2.);
    let a = (1. - config.grid.dt * &v / 2.) * &b;

    // We can't do this in a par.
    // AFAIK, this is the safest way to work with the float here.
    for el in v.iter() {
        if el.is_finite() {
            minima = minima.min(*el);
        }
    }
    //Get 2*abs(min(potential)) for offset of beta
    let epsilon = 2. * minima.abs();

    Potentials {
        v: v,
        a: a,
        b: b,
        epsilon: epsilon,
    }
}

/// Fills potential and wavefunction variables with the required initial conditions
/// Reads from disk if need be due to user input from the configuration file. Writes
/// output if this also has been requested.
///
/// # Arguments
///
/// * `config` - The configuration struct for the programs current instance.
fn initialise(config: &Config, log: &Logger) -> Params {
    info!(log, "Loading potential arrays");
    let potentials = load_potential_arrays(config);

    if config.output.save_potential {
        //TODO: Build output routine.
        //Not sure if we should use someting like messagepack as there are matlab
        //and python bindings, or try for hdf5. The rust bindings there are pretty
        //shonky. So not sure. We'll need a text only option anyhow, so build that fist.
    }

    if config.wavenum > 0 {
        //TODO: We restart from an output file.
    }

    info!(log, "Setting initial conditions for wavefunction");
    let phi = set_initial_conditions(config);
    Params {
        potentials: potentials,
        phi: phi,
    }
}

/// Runs the actual computation once system is setup and ready.
pub fn solve(config: &Config, log: &Logger) {

    let params = initialise(config, log);
    //    let mut step = 1.;
    //    let mut done = false;
    // while !done {
    //     //syncboundaries <- not needed until MPI
    info!(log, "Computing observables");
    compute_observables(config, &params);
    //     //symmetrise_wavefunction
    //     //normalise_wavefunction
    //     //orthognalise_wavefunction (if wavenum>0)
    //     //output_measurements
    //     if step < config.max_steps {
    //         evolve(config.output.screen_update, &params.phi);
    //     }
    //     step += config.output.screen_update;
    //     done = step <= config.max_steps;
    // }

}

/// Computes observable values of the system, for example the energy
fn compute_observables(config: &Config, params: &Params) {
    let energy = wfnc_energy(config, params);
    println!("Energy: {}", energy);
}

/// Gets energy of the corresponding wavefunction
//TODO: We can probably drop the config requirement and replace it with a grid modifier of dn*mass
fn wfnc_energy(config: &Config, params: &Params) -> f64 {
    let num = &config.grid.size; //NOTE: We could also obtain this by phi.dim() if other config values are not needed.

    let w = params
        .phi
        .slice(s![3..3 + num.x as isize,
                  3..3 + num.y as isize,
                  3..3 + num.z as isize]);
    let v = params
        .potentials
        .v
        .slice(s![3..3 + num.x as isize,
                  3..3 + num.y as isize,
                  3..3 + num.z as isize]);

    let mut work = Array3::<f64>::zeros(w.dim());
    //NOTE: TODO: We don't have any complex conjugation here.
    // Complete matrix multiplication step using 7 point central differenc
    // TODO: Option for 3 or 5 point caclulation
    Zip::indexed(&mut work)
        .and(v)
        .and(w)
        .par_apply(|(i, j, k), work, &v, &w| {
            // Offset indexes as we are already in a slice
            let lx = i as isize + 3;
            let ly = j as isize + 3;
            let lz = k as isize + 3;
            let o = 3;
            // get a slice which gives us our matrix of central difference points
            let l = params
                .phi
                .slice(s![lx - 3..lx + 4, ly - 3..ly + 4, lz - 3..lz + 4]);
            // l can now be indexed with local offset `o` and modifiers
            *work = v * w * w -
                    w *
                    (2. * l[[o + 3, o, o]] - 27. * l[[o + 2, o, o]] + 270. * l[[o + 1, o, o]] +
                     270. * l[[o - 1, o, o]] -
                     27. * l[[o - 2, o, o]] + 2. * l[[o - 3, o, o]] +
                     2. * l[[o, o + 3, o]] - 27. * l[[o, o + 2, o]] +
                     270. * l[[o, o + 1, o]] +
                     270. * l[[o, o - 1, o]] -
                     27. * l[[o, o - 2, o]] + 2. * l[[o, o - 3, o]] +
                     2. * l[[o, o, o + 3]] - 27. * l[[o, o, o + 2]] +
                     270. * l[[o, o, o + 1]] +
                     270. * l[[o, o, o - 1]] -
                     27. * l[[o, o, o - 2]] + 2. * l[[o, o, o - 3]] -
                     1470. * w) / (360. * config.grid.dn.powi(2) * config.mass);
        });
    // Sum result for total energy.
    work.scalar_sum()
}


/// Evolves the solution a number of `steps`
fn evolve(steps: f64, w: &Array3<f64>) {}
