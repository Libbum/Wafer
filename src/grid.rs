use ndarray::{Array3, ArrayView3, Zip};
use ndarray_parallel::prelude::*;
use slog::Logger;
use potential;
use config;
use config::*;

#[derive(Debug)]
pub struct Potentials {
    pub v: Array3<f64>,
    a: Array3<f64>,
    b: Array3<f64>,
    epsilon: f64,
}

/// Parameters generated by the initialisation routine, potentials and wavefunction (phi).
#[derive(Debug)]
struct Params<'a> {
    potentials: Potentials,
    phi: &'a mut Array3<f64>,
}

#[derive(Debug)]
struct Observables {
    energy: f64,
    norm2: f64,
    v_infinity: f64,
    r2: f64,
}

fn load_potential_arrays(config: &Config) -> Potentials {
    let mut minima: f64 = 1e20;

    let result = match config.potential {
        PotentialType::FromFile => potential::from_file(),
        PotentialType::FromScript => potential::from_script(),
        _ => potential::generate(config),
    };
    let v: Array3<f64> = match result {
        Ok(r) => r,
        Err(err) => panic!("Error: {}", err),
    };


    let b = 1. / (1. + config.grid.dt * &v / 2.);
    let a = (1. - config.grid.dt * &v / 2.) * &b;

    // We can't do this in a par.
    // AFAIK, this is the safest way to work with the float here.
    for el in v.iter() {
        if el.is_finite() {
            minima = minima.min(*el);
        }
    }
    //Get 2*abs(min(potential)) for offset of beta
    let epsilon = 2. * minima.abs();

    Potentials {
        v: v,
        a: a,
        b: b,
        epsilon: epsilon,
    }
}

/// Runs the actual computation once system is setup and ready.
pub fn solve(config: &Config, log: &Logger) {

    info!(log, "Loading potential arrays");
    let params = Params {
        potentials: load_potential_arrays(config),
        phi: &mut set_initial_conditions(config),
    };
    info!(log, "Setting initial conditions for wavefunction");
    if config.output.save_potential {
        //TODO: Build output routine.
        //Not sure if we should use someting like messagepack as there are matlab
        //and python bindings, or try for hdf5. The rust bindings there are pretty
        //shonky. So not sure. We'll need a text only option anyhow, so build that fist.
    }

    if config.wavenum > 0 {
        //TODO: We restart from an output file.
    }

    //let params = Params::initialise(config, log);
    let step = 0;
    //    let mut done = false;
    // while !done {
    //     //syncboundaries <- not needed until MPI
    info!(log, "Computing observables");
    let observables = compute_observables(config, &params);
    println!("{:?}", observables);
    if step % config.output.snap_update == 0 {
        //TODO: I think we can do away with SNAPUPDATE now. Kill this if.
        info!(log, "snapupdate: symmetrise");
        config::symmetrise_wavefunction(config, params.phi);
        normalise_wavefunction(params.phi, observables.norm2);
    }
    //     //orthognalise_wavefunction (if wavenum>0)
    //     //output_measurements
    //     if step < config.max_steps {
    //         evolve(config.output.screen_update, &params.phi);
    //     }
    //     step += config.output.screen_update;
    //     done = step <= config.max_steps;
    // }

}

/// Computes observable values of the system, for example the energy
fn compute_observables(config: &Config, params: &Params) -> Observables {
    let energy = wfnc_energy(config, params);
    let dims = params.phi.dim();
    let work = params.phi
        .slice(s![3..(dims.0 as isize) - 3, 3..(dims.1 as isize) - 3, 3..(dims.2 as isize) - 3]);

    let norm2 = get_norm_squared(&work);
    let v_infinity = get_v_infinity_expectation_value(&work, config);
    let r2 = get_r_squared_expectation_value(&work, &config.grid);

    Observables {
        energy: energy,
        norm2: norm2,
        v_infinity: v_infinity,
        r2: r2,
    }
}

/// Normalisation of wavefunction
fn get_norm_squared(w: &ArrayView3<f64>) -> f64 {
    //NOTE: No complex conjugation due to all real input for now
    (w * w).scalar_sum()
}

/// Get v infinity
fn get_v_infinity_expectation_value(w: &ArrayView3<f64>, config: &Config) -> f64 {
    //NOTE: No complex conjugation due to all real input for now
    let mut work = Array3::<f64>::zeros(w.dim());
    Zip::indexed(&mut work)
        .and(w)
        .par_apply(|(i, j, k), work, &w| {
            let idx = Index3 { x: i, y: j, z: k };
            let potsub = match potential::potential_sub(config, &idx) {
                Ok(p) => p,
                Err(err) => panic!("Error: {}", err),
            };
            *work = w * w * potsub;
        });
    work.scalar_sum()
}

/// Get r2
fn get_r_squared_expectation_value(w: &ArrayView3<f64>, grid: &Grid) -> f64 {
    //NOTE: No complex conjugation due to all real input for now
    let mut work = Array3::<f64>::zeros(w.dim());
    Zip::indexed(&mut work)
        .and(w)
        .par_apply(|(i, j, k), work, &w| {
            let idx = Index3 { x: i, y: j, z: k };
            let r = potential::calculate_r(&idx, grid);
            *work = w * w * r;
        });
    work.scalar_sum()
}

/// Gets energy of the corresponding wavefunction
//TODO: We can probably drop the config requirement and replace it with a grid modifier of dn*mass
fn wfnc_energy(config: &Config, params: &Params) -> f64 {
    let num = &config.grid.size; //NOTE: We could also obtain this by phi.dim() if other config values are not needed.

    let w = params.phi
        .slice(s![3..3 + num.x as isize, 3..3 + num.y as isize, 3..3 + num.z as isize]);
    let v = params.potentials
        .v
        .slice(s![3..3 + num.x as isize, 3..3 + num.y as isize, 3..3 + num.z as isize]);

    let mut work = Array3::<f64>::zeros(w.dim());
    //NOTE: TODO: We don't have any complex conjugation here.
    // Complete matrix multiplication step using 7 point central differenc
    // TODO: Option for 3 or 5 point caclulation
    Zip::indexed(&mut work)
        .and(v)
        .and(w)
        .par_apply(|(i, j, k), work, &v, &w| {
            // Offset indexes as we are already in a slice
            let lx = i as isize + 3;
            let ly = j as isize + 3;
            let lz = k as isize + 3;
            let o = 3;
            // get a slice which gives us our matrix of central difference points
            let l = params.phi
                .slice(s![lx - 3..lx + 4, ly - 3..ly + 4, lz - 3..lz + 4]);
            // l can now be indexed with local offset `o` and modifiers
            *work = v * w * w -
                    w *
                    (2. * l[[o + 3, o, o]] - 27. * l[[o + 2, o, o]] + 270. * l[[o + 1, o, o]] +
                     270. * l[[o - 1, o, o]] -
                     27. * l[[o - 2, o, o]] + 2. * l[[o - 3, o, o]] +
                     2. * l[[o, o + 3, o]] - 27. * l[[o, o + 2, o]] +
                     270. * l[[o, o + 1, o]] +
                     270. * l[[o, o - 1, o]] -
                     27. * l[[o, o - 2, o]] + 2. * l[[o, o - 3, o]] +
                     2. * l[[o, o, o + 3]] - 27. * l[[o, o, o + 2]] +
                     270. * l[[o, o, o + 1]] +
                     270. * l[[o, o, o - 1]] -
                     27. * l[[o, o, o - 2]] + 2. * l[[o, o, o - 3]] -
                     1470. * w) / (360. * config.grid.dn.powi(2) * config.mass);
        });
    // Sum result for total energy.
    work.scalar_sum()
}

fn normalise_wavefunction(w: &mut Array3<f64>, norm2: f64) {
    //TODO: This can be moved directly into the calculation for now. It's only here due to normalisationCollect
    let norm = norm2.sqrt();
    w.par_map_inplace(|el| *el /= norm);
}
/// Evolves the solution a number of `steps`
fn evolve(steps: f64, w: &Array3<f64>) {}
