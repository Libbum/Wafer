//! **Wa** ve **f** unction Solv **er**: a parallelized, 3D, Schrödinger equation solver.
//!
//! Wafer exploits a Wick-rotated time-dependent Schrödinger equation to solve for
//! time-independent solutions in three dimensions.
//!
//! Inspired by [quantumfdtd](http://sourceforge.net/projects/quantumfdtd/),
//! which is a proof of concept tool and falls short of a general purpose utility.
//! Wafer attempts to remedy this issue.
//!
//! If you use Wafer in your research, please reference the following articles:
//!
//! M. Strickland and D. Yager-Elorriaga, “A parallel algorithm for solving the 3d
//! Schrödinger equation”,
//! [Journal of Computational Physics __229__, 6015–6026 (2010)](http://dx.doi.org/10.1016/j.jcp.2010.04.032).


#![cfg_attr(feature="clippy", feature(plugin))]
#![cfg_attr(feature="clippy", plugin(clippy))]

extern crate ansi_term;
#[macro_use(s)]
extern crate ndarray;
extern crate ndarray_parallel;
extern crate num;
extern crate rand;
extern crate rayon;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate serde_json;
extern crate term_size;

use ansi_term::Colour::Blue;
use ndarray::{Array3, Zip};
use ndarray_parallel::prelude::*;
use std::time::Instant;
use config::Config;

include!(concat!(env!("OUT_DIR"), "/version.rs"));

/// Config is a (mostly) public module which reads the configuration file `wafer.cfg`
/// and poplulates the `Config` struct with the information required to run the current
/// instance of the application.
pub mod config;
mod grid;
mod potential;

/// Parameters generated by the initialisation routine, potentials and wavefunction (phi).
struct Params {
    potentials: grid::Potentials,
    phi: Array3<f64>,
}

/// Uses **term_size** to pull in the terminal width and from there sets the output
/// pretty printing value to an appropreate value (between 70-100). Also sets the
/// sha length for the banner output.
fn get_term_size() -> (usize, String) {
    let mut sha = sha();
    let mut term_width = 100;
    if let Some((width, _)) = term_size::dimensions() {
        if width <= 97 {
            sha = short_sha();
        }
        if width <= 70 {
            term_width = 70;
        } else if width < term_width {
            term_width = width;
        }
    }
    (term_width, sha.to_string())
}

/// Simply prints the Wafer banner with current commit info and thread count.
fn print_banner(sha: String) {
    println!("                    {}", Blue.paint("___"));
    println!("   __      ____ _  {}__ _ __", Blue.paint("/ __\\"));
    println!("   \\ \\ /\\ / / _` |{} / _ \\ '__|", Blue.paint("/ /"));
    println!("    \\ V  V / (_| {}|  __/ |    Current build SHA1: {}",
             Blue.paint("/ _\\"),
             sha);
    println!("     \\_/\\_/ \\__,{}   \\___|_|    Parallel tasks running on {} threads.",
             Blue.paint("/ /"),
             rayon::current_num_threads());
    println!("              {}", Blue.paint("\\__/"));
    println!("");
}

/// Fills potential and wavefunction variables with the required initial conditions
/// Reads from disk if need be due to user input from the configuration file. Writes
/// output if this also has been requested.
///
/// # Arguments
///
/// * `config` - The configuration struct for the programs current instance.
fn initialise(config: &Config) -> Params {
    let potentials = grid::load_potential_arrays(config);

    if config.output.save_potential {
        //TODO: Build output routine.
        //Not sure if we should use someting like messagepack as there are matlab
        //and python bindings, or try for hdf5. The rust bindings there are pretty
        //shonky. So not sure. We'll need a text only option anyhow, so build that fist.
    }

    if config.wavenum > 0 {
        //TODO: We restart from an output file.
    }

    let phi = config::set_initial_conditions(config);
    Params {
        potentials: potentials,
        phi: phi,
    }
}

/// Runs the actual computation once system is setup and ready.
fn solve(config: &Config, params: &Params) {
    //    let mut step = 1.;
    //    let mut done = false;
    // while !done {
    //     //syncboundaries <- not needed until MPI
    compute_observables(config, params);
    //     //symmetrise_wavefunction
    //     //normalise_wavefunction
    //     //orthognalise_wavefunction (if wavenum>0)
    //     //output_measurements
    //     if step < config.max_steps {
    //         evolve(config.output.screen_update, &params.phi);
    //     }
    //     step += config.output.screen_update;
    //     done = step <= config.max_steps;
    // }

}

/// Computes observable values of the system, for example the energy
fn compute_observables(config: &Config, params: &Params) {
    let energy = wfnc_energy(config, params);
    println!("Energy: {}", energy);
}

/// Gets energy of the corresponding wavefunction
//TODO: We can probably drop the config requirement and replace it with a grid modifier of dn*mass
fn wfnc_energy(config: &Config, params: &Params) -> f64 {
    let num = &config.grid.size; //NOTE: We could also obtain this by phi.dim() if other config values are not needed.

    let w = params.phi
        .slice(s![3..3 + num.x as isize, 3..3 + num.y as isize, 3..3 + num.z as isize]);
    let v = params.potentials
        .v
        .slice(s![3..3 + num.x as isize, 3..3 + num.y as isize, 3..3 + num.z as isize]);

    let mut work = Array3::<f64>::zeros(w.dim());
    //NOTE: TODO: We don't have any complex conjugation here.
    // Complete matrix multiplication step using 7 point central differenc
    // TODO: Option for 3 or 5 point caclulation
    Zip::indexed(&mut work).and(v).and(w).par_apply(|(i, j, k), work, &v, &w| {
        // Offset indexes as we are already in a slice
        let lx = i as isize + 3;
        let ly = j as isize + 3;
        let lz = k as isize + 3;
        let o = 3;
        // get a slice which gives us our matrix of central difference points
        let l = params.phi.slice(s![lx - 3..lx + 4, ly - 3..ly + 4, lz - 3..lz + 4]);
        // l can now be indexed with local offset `o` and modifiers
        *work =
            v * w * w -
            w *
            (2. * l[[o + 3, o, o]] - 27. * l[[o + 2, o, o]] + 270. * l[[o + 1, o, o]] +
             270. * l[[o - 1, o, o]] - 27. * l[[o - 2, o, o]] + 2. * l[[o - 3, o, o]] +
             2. * l[[o, o + 3, o]] - 27. * l[[o, o + 2, o]] +
             270. * l[[o, o + 1, o]] + 270. * l[[o, o - 1, o]] -
             27. * l[[o, o - 2, o]] +
             2. * l[[o, o - 3, o]] + 2. * l[[o, o, o + 3]] -
             27. * l[[o, o, o + 2]] + 270. * l[[o, o, o + 1]] +
             270. * l[[o, o, o - 1]] -
             27. * l[[o, o, o - 2]] + 2. * l[[o, o, o - 3]] - 1470. * w) /
            (360. * config.grid.dn.powi(2) * config.mass);
    });
    // Sum result for total energy.
    work.scalar_sum()
}


/// Evolves the solution a number of `steps`
fn evolve(steps: f64, w: &Array3<f64>) {}

fn main() {

    let start_time = Instant::now();

    let (term_width, sha) = get_term_size();
    print_banner(sha);

    let config = Config::load();
    config.print(term_width);

    let params = initialise(&config);
    solve(&config, &params);

    let elapsed = start_time.elapsed();
    let time_taken = (elapsed.as_secs() as f64) + (elapsed.subsec_nanos() as f64 / 1000_000_000.0);
    println!("Elapsed time: {} seconds.", time_taken);
}

#[cfg(test)]
mod tests {
    #[test]
    fn placeholder() {
        let num = 5;
        assert_eq!(num, 5);
    }
}
